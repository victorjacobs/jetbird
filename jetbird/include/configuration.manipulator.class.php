<?php

	/*	This file is part of Jetbird.
	
	    Jetbird is free software: you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation, either version 3 of the License, or
	    (at your option) any later version.
	
	    Jetbird is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with Jetbird.  If not, see <http://www.gnu.org/licenses/>.
	*/
	
	class configuration_manipulator{
		private $status, $raw_data, $out_array = array(), $out_string, $out_temp;
		
		// Declare some statics
		const FILE_BASE =
"<?php

	/*	This file is part of Jetbird.

	    Jetbird is free software: you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation, either version 3 of the License, or
	    (at your option) any later version.

	    Jetbird is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.

	    You should have received a copy of the GNU General Public License
	    along with Jetbird.  If not, see <http://www.gnu.org/licenses/>.
	*/

	/* File generated by configuration_manipulator class on ///DATEPLACEHOLDER/// */

///DATAPLACEHOLDER///

?>";
		
		public function __construct(){
			// Parse $config, before we check whether this is clean install.
			//  We do this because the bare configuration contains some essential default settings
			$this->parse_config_to_array();
		}
		
		public function add_var($path, $data){
			list($parent, $child) = $this->eval_path($path);
			
			$this->out_array[$parent][$child] = $data;
		}
		
		private function parse_config_to_array(){
			global $config;
			
			$this->out_array = array_merge($config, $this->out_array);
		}
		
		private function out_array_to_string(){
			// Sort out_array, TODO: sort childs
			ksort($this->out_array);
			
			foreach($this->out_array as $parent => $var){
				$this->out_temp .= "\t" . '// '. ucfirst($parent) .' settings' . "\n";
				
				foreach($var as $child => $data){
					$this->out_temp .= "\t" . '$config[\''. $parent .'\'][\''. $child .'\'] = ';
					
					if(is_int($data)){
						$this->out_temp .= $data . ";";
					}elseif(is_string($data)){
						$this->out_temp .= '"'. $data .'";';
					}elseif(is_bool($data)){
						if($data){
							$this->out_temp .= 'true;';
						}else{
							$this->out_temp .= 'false;';
						}
					}
					
					$this->out_temp .= "\n";
				}
				
				$this->out_temp .= "\n";
			}
			
			return $this->out_temp;
		}
		
		private function generate(){
			$this->out_string = str_replace("///DATAPLACEHOLDER///", rtrim($this->out_array_to_string()), configuration_manipulator::FILE_BASE);
			$this->out_string = str_replace("///DATEPLACEHOLDER///", date("c"), $this->out_string);
			
			return $this->out_string;
		}
		
		private function eval_path($path){
			if(empty($path)) return false;
			
			// Clean up the path
			$temp = explode("/", $path);
			if(count($temp) > 4) return false;
			if(empty($temp[0])) array_shift($temp);
			if(empty($temp[count($temp) - 1])) array_pop($temp);
			
			list($parent, $child) = $temp;
			
			return array($parent, $child);
		}
		
		public function write(){
			$out = find("include/") . "configuration.php";
			
			if(!($file_handle = fopen($out, "w"))){
				die("Could not lock $out for writing");
			}
			
			fwrite($file_handle, $this->generate());
			fclose($file_handle);
		}
		
	}

?>